% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parapower.R
\name{parapower}
\alias{parapower}
\alias{convert_effect}
\alias{critical_effect}
\title{Parametric Power Analysis}
\usage{
parapower(effect = NULL, type = "f", N = NULL, k = 2, alpha = 0.05,
  power = 0.8, range)

convert_effect(effect, type = "r", N = 3, k = 2, adjust_f = TRUE,
  display_f = FALSE, print = TRUE)

critical_effect(N, k = 2, alpha = 0.05)
}
\arguments{
\item{effect}{Effect size of the specified type.}

\item{type}{Type of effect entered. Available types are Pearson's r (\code{r}), Cohen's d
(\code{d}), Area Under the Curve (AUC; \code{a}), Odds Ratio (\code{o}), η2 (eta-squared; R2;
\code{e}), or Cohen's f (\code{f}).}

\item{N}{Total sample size.}

\item{k}{Number of groups or cells, with 2 being the default and most generally appropriate.}

\item{alpha}{Alpha level (p-value; theoretical type I error / false positive).}

\item{power}{Power (\code{1 – β}; inverse theoretical type II error / false negative).}

\item{range}{Interval of the estimated component for the optimizer to try. Defaults to
\code{c(2, 10000)} for \code{N}, \code{c(0, 100)} for \code{effect}, and
\code{c(0, 1)} for \code{power} or \code{alpha}. If you get an error from \code{uniroot} (like
\code{"f() values at end points not of opposite sign"}), try increasing the range
(e.g., smaller low end for large effects, and larger high end for small effects).}

\item{adjust_f}{Logical indicating whether the entered effect of type \code{f} should be converted
from F to Cohen's f based on \code{N} and \code{k}: \code{sqrt((k - 1) * F / (N - k))}.}

\item{display_f}{Logical; if TRUE, calculates F and an associated p-value based on
\code{N} and \code{k}.}

\item{print}{Logical; if \code{FALSE}, results are only invisibly returned.}
}
\description{
Parametric effect size related functions for tests along the lines of balanced ANOVAs
(e.g., certain t-tests, correlations, and regressions).
}
\details{
This type of power analysis becomes increasingly difficult with more complex models.
In those cases, simulation is very handy (though more difficult to abstract in terms
of specification) –- if you can reasonably simulate the data you have in mind,
you can reasonably estimate power for any model. See the Monte Carlo section of the examples.
}
\examples{
# a priori power analysis (looking for n given an effect size, alpha, and power)
# with no arguments, this defaults to effect = c(.3, .5, .7), type = 'd'
parapower()

# sensitivity analysis (looking for an effect size given n, alpha, and power)
parapower(N = 50)

# post-hoc power analysis (looking for power given an effect size, n, and alpha)
# since 'f' is the default type, this is power given Cohen's f = .3
parapower(.3, N = 50)

# criterion analysis (looking for alpha given an effect size, n, and power)
parapower(.3, N = 50, power = .8)

#
# Monte Carlo power analysis
#

# simulate a simple effect: continuous normal x and related y
N <- 20
x <- rnorm(N)
y <- x * .4 + rnorm(N)
summary(lm(y ~ x))

## here, we can input the correlation to get other effect sizes
## k defaults to 2, which is appropriate in this case
convert_effect(cor(x, y), N = N)

## we want to know what N gives us .8 power to detect this effect at .05 alpha
## we can set up a function to easily try different Ns
sim1 <- function(N, beta = .4, batches = 100, alpha = .05, power = .8) {
  # first, set up a vector of 0s, which we'll fill with results from each run
  op <- numeric(batches)
  # now we repeat the simulation batches times
  # (with i tracking the index of op)
  for (i in seq_len(batches)) {
    # reroll the simulated variables
    x <- rnorm(N)
    y <- x * beta + rnorm(N)
    # set the current op entry to the p-value of the test
    op[i] <- summary(lm(y ~ x))$coef[2, 4]
  }
  # observed power is percent of p-values under alpha
  # output of the function is observed power - set power for optimization
  # (where the target is 0; closest observed to set power)
  mean(op < alpha) - power
}

## uniroot will try different values of N (between 20 and 100 here),
## and output the one that gets closest to the set power
uniroot(sim1, c(20, 100))$root

\dontrun{

## setting power to 0 will give the observed power
## increase batches for more stable estimates
sim1(55, batches = 5000, power = 0)

## compare with a binary x
sim1b <- function(N, beta = .4, batches = 100, alpha = .05, power = .8) {
  op <- numeric(batches)
  for (i in seq_len(batches)) {
    x <- rep_len(c(0, 1), N)
    y <- x * beta + rnorm(N)
    op[i] <- summary(lm(y ~ x))$coef[2, 4]
  }
  mean(op < alpha) - power
}
uniroot(sim1b, c(100, 300))$root
sim1b(200, batches = 5000, power = 0)

# this is what the most basic parametric power analysis is getting at
parapower(.4, "d")

# simulate a more complicated effect: two binary variables with an interaction effect
c1 <- sample(c(0, 1), N, TRUE)
c2 <- sample(c(0, 1), N, TRUE)
y <- c2 * c1 * .8 + rnorm(N)
(m <- summary(lm(y ~ c1 * c2)))

## R-squared is eta^2, and k is 4 (2x2)
convert_effect(m$r.squared, "eta^2", N, 4)

## same kind of function as before, only difference is the simulated data and test
## also have to recalculate the omnibus p-value since it's not returned
sim2 <- function(N, beta = .8, batches = 100, alpha = .05, power = .8) {
  op <- numeric(batches)
  for (i in seq_len(batches)) {
    c1 <- sample(c(0, 1), N, TRUE)
    c2 <- sample(c(0, 1), N, TRUE)
    y <- c2 * c1 * beta + rnorm(N)
    f <- summary(lm(y ~ c1 * c2))$fstatistic
    op[i] <- pf(f[1], f[2], f[3], lower.tail = FALSE)
  }
  mean(op < alpha) - power
}
uniroot(sim2, c(50, 300))$root
sim2(100, batches = 5000, power = 0)

## note here that we're looking at the omnibus test
## if you're actually interested in, say, the interaction effect, that may affect power
sim2i <- function(N, beta = .8, batches = 100, alpha = .05, power = .8) {
  op <- numeric(batches)
  for (i in seq_len(batches)) {
    c1 <- sample(c(0, 1), N, TRUE)
    c2 <- sample(c(0, 1), N, TRUE)
    y <- c2 * c1 * beta + rnorm(N)
    op[i] <- summary(lm(y ~ c1 * c2))$coef[4, 4]
  }
  mean(op < alpha) - power
}
uniroot(sim2i, c(100, 300))$root
sim2i(200, batches = 5000, power = 0)
}
}
